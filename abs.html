
<!-- saved from url=(0090)https://basics.sjtu.edu.cn/~chen/Events/2017NSFC-JSPS/?from=singlemessage&isappinstalled=0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>
Abstracts of Talks
</title>
  
  <link type="text/css" href="./The 10th NSFC-JSPS Joint Workshop on Formal Methods_files/hu.css" rel="stylesheet">

<!--<base href="http://basics.sjtu.edu.cn/~chen/.">--><base href=".">

</head><body bgcolor="#F5F5DC" link="#0000F0" vlink="#000090" background="./The 10th NSFC-JSPS Joint Workshop on Formal Methods_files/back.jpg">

<style>
BODY {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}

H1 {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}

P {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}
a {text-decoration:none}
</style>




<h1>Abstracts</h1>

<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="ogawa"></a><strong>Title</strong>: Model checking event clock automata (Mizuhito Ogawa)<br>
<strong>Abstract</strong>: Model checking event clock automata has been an open problem, even for discrete CTL. The difficulty lies the failure of the finite region construction for event clock automata, contrary to what widely believed, We investigate how the well quasi ordering techniques work for the problem. </p>


<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="YuxiFu"></a><strong>Title</strong>: Reaching to the Top of the Tower (Yuxi Fu)<br>
<strong>Abstract</strong>: We will talk about a new complexity upper bound (much better than the one you heard me talking about last time in Japan) on the VASS reachability problem.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="seki"></a><strong>Title</strong>: Regularity Preservation Property of Register Pushdown Systems (Hiroyuki Seki)<br>
<strong>Abstract</strong>: Pushdown system (PDS) is an infinite-state model for recursive schema and 
PDS preserves regularity, where a transformation T is said to preserve regularity 
if T(L) is always regular for any regular language L. 
Register pushdown system (RPDS) is an extension of PDS by adding the capability 
of manipulating data values in a restricted way.  Murawski et al. showed that 
every RPDS has backward (pre*) regularity preservation property. Note that
we say that a data language L is regular if L is recognized by a register automaton. 
In this talk, we first propose an alternative definition of RPDS by using equivalence 
relation between registers. Then, it is shown that every RPDS has both backward 
and forward (post*) regularity preservation property.  Also, we discuss an application 
of these preservation results to RPDS model checking problems. 
<br>
This is a joint work with Ryoma Senda and Yoshiaki Takata. </p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="terauchi"></a><strong>Title</strong>: Synthesizing Simple Strategies for Efficient Counterexample-Guided Quantified SMT Solving (Tachio Terauchi)<br>
<strong>Abstract</strong>: We present a new algorithm for deciding the satisfiability of SMT formulas containing quantifiers.  We build our algorithm on the recent approach proposed by Farzan and Kincaid that reduces the problem to synthesizing a winning strategy to a certain perfect-information two-player game.  We show that their approach (as well as similar approaches used in Z3 and CVC4) can be inefficient incurring exponentially many strategy synthesis iterations even on simple examples having linear-size winning strategies.  Then, we present a new strategy synthesis approach that is able to efficiently solve such instances by quickly converging to simple winning strategies. (This is a work-in-progress work.)
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="nakazawa"></a><strong>Title</strong>: Proof normalization for classical truth-table natural deduction (Koji Nakazawa)<br>
<strong>Abstract</strong>: Geuvers et al. proposed a framework in which we can induce
natural-deduction-style
inference rules for general logical connectives from their truth
tables. They also defined
the proof normalization for intuitionistic variant of the truth-table
natural deduction (TTND)
and van der Giessen proved the subformula property and the strong
normalization, which are
important properties deriving consistency and conservativeness.
However, for Geuvers'
original definition of classical variant of TTND, it seems hard to
define the proof normalization
with good properties. In this talk, we proposed another classical
variant of TTND, which is an
extension of the intuitionistic TTND with multiple conclusion
sequents, and in which we can
easily get the notion of proof normalization along the idea of
Parigot's lambda-mu calculus.
We also prove the subformula property and strong normalization of the
proof normalization
in classical TTND. 
<br>
<br>
This is a joint work with Kosuke Fukui and Saori Ishii.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="xudong"></a><strong>Title</strong>:  Verifying Quantum Communication Protocols with Ground Bisimulation (Xudong Qin)<br>
<strong>Abstract</strong>: One important application of quantum process algebras is to formally verify quantum communication protocols. With a suitable notion of behavioural equivalence and a decision method, one can determine if an implementation of a protocol is consistent with its specification. Ground bisimulation is a convenient behavioural equivalence for quantum processes because of its associated coinduction proof technique. We exploit this technique to design and implement two on-the-fly algorithms for  the strong and weak versions of ground bisimulation to check if two given processes in quantum CCS are equivalent. We then develop a tool that can verify interesting quantum protocols such as the BB84 quantum key distribution scheme. </p>
<hr>

<p style="width: 800px" align="left"><a name="YuxiFu" id="yuen"></a><strong>Title</strong>: Reversing Parallel Programs with Blocks and Procedures (Shoji Yuen)<br>
<strong>Abstract</strong>: We show how to reverse a while language extended with blocks, local variables, procedures and the
interleaving parallel composition. Annotation is defined along with a set of operational semantics
capable of storing necessary reversal information, and identifiers are introduced to capture the interleaving
order of an execution. Inversion is defined with a set of operational semantics that use
saved information to undo an execution. We prove that annotation does not alter the behaviour of the
original program, and that inversion correctly restores the initial program state.<br>
(Joint work with: James Hoey and Irek Ulidowski)</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="song"></a><strong>Title</strong>: Verifying and Quantifying Side-Channel Resistance of Masked Software Implementations.   (Fu Song) <br>
<strong>Abstract</strong>: Power side-channel attacks, capable of deducing secret data using statistical analysis, have become a serious
threat. Random masking is a widely used countermeasure for removing the statistical dependence between
secret data and side-channel information. Although there are techniques for verifying whether a software
has been perfectly masked, they are limited in accuracy and scalability. To bridge this gap, we propose a
refinement-based method for verifying masking. Our method is more accurate than prior type inference based
approaches and more scalable than prior model-counting based approaches using SAT or SMT solvers. Indeed,
our approach can be viewed as a gradual refinement of a set of type inference rules for reasoning about
distribution types. These rules are kept abstract initially to allow fast deduction, and then made concrete when
the abstract version is not able to resolve the verification problem. We also propose algorithms for quantifying
the amount of information leakage from a software implementation through side channels using the notion of
Quantitative Masking Strength. We have implemented our method in a tool and evaluated it on cryptographic
benchmarks including AES and MAC-Keccak. The experimental results show that our method significantly
outperforms state-of-the-art techniques in terms of both accuracy and scalability.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="deng"></a><strong>Title</strong>: On Divergence-Sensitive Weak Probabilistic Bisimilarity (Kangli He) <br>
<strong>Abstract</strong>: Weak probabilistic bisimilarity is a well-established notion to equate concurrent probabilistic systems that behave observably equivalent, up to the matching of internal computation steps. This notion can be pivotal in the model checking of large probabilistic systems, because the considered model can be replaced by an equivalent, but possibly much smaller one prior to model checking. The conventional work has thus far considered weak probabilistic bisimilarity while ignoring the presence or absence of divergent behavior (interpreted as inﬁnite internal computations). However, we argue that divergence can have a remarkable inﬂuence on the equivalence of two concurrent probabilistic systems. We thus explore divergence-sensitive reﬁnements of weak probabilistic bisimilarity. We work in the setting of probabilistic automata, and study the consistent feasible veriﬁcation method for the notion of divergence-sensitivity that discriminates presence and absence of divergence in otherwise bisimilar states. We furthermore present a novel polynomial-time algorithm to compute divergence-sensitive bisimilarity. It intertwines partition-reﬁnement and inductive veriﬁcation steps in a highly non-trivial manner.</p>


<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="imgai"></a><strong>Title</strong>: Fully Static Multiparty Session Programming with Global
Protocol Combinators
 (Keigo Imai)<br>
<strong>Abstract</strong>: Multiparty Session Types (MPST) is a typing discipline for
communication protocols. It ensures the absence of communication
errors and deadlocks for well-typed communicating processes. Current
implementations of the MPST theory rely on (1) runtime linearity
checks to ensure correct usage of communication channels and (2)
external domain specific languages for specifying and verifying of
multiparty protocols.
<br><br>
To overcome these limitations, we propose a library for programming
with global combinators -- a set of functions for writing and
verifying multiparty protocols in OCaml.  Local behaviours for all
processes in a protocol are inferred at once from a global combinator.
We formalise our implementation in MiO, a minimal session-based
functional language, and prove that MiO is type-safe.  Our approach
enables fully-static verification and implementation of the whole
protocol, from the protocol specification to the process
implementations, to happen in the same language.
<br><br>
We compare our implementation to untyped and continuation-passing
style implementations, and demonstrate its expressiveness by
implementing a plethora of protocols. We show our library can
interoperate with existing libraries and services, implementing DNS
(Domain Name Service) protocol and the OAuth (Open Authentication)
protocol.
<br><br>
This is joint work with Rumyana Neykova (Brunel University London, UK)
and Nobuko Yoshida (Imperial College London, UK).

 </p>



<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="gardy"></a><strong>Title</strong>:  Incomplete
information in multi-execution properties for multi-agent systems
 (Patrick Gardy)<br>
<strong>Abstract</strong>:  Imperfect information is a well known and well studied subject of software
verification. In closed systems (systems independent of their environments) there have been many results. When moving to open systems (reacting to their environments), the situation changes
drastically and imperfect information greatly complexify the results. In particular, the model-checking of many models rises in complexity or turn outright undecidable. In this talk we present the different
shapes imperfect information takes in multi-agents systems, some well-known (partial observation of the state space) and some less famous (strategies dependencies during synthesis, delayed use). We
will present recent algorithm developments and new complexity results.
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="chen"></a><strong>Title</strong>: Łoś and Tarski meet Lovász (Yijia Chen)<br>
<strong>Abstract</strong>: The Łoś–Tarski preservation theorem states that any FO-definable property which is closed under induced substructures can be defined by a universal FO-sentence. We show that this theorem can give a pure logic proof of the following result due to Lovász.
<br><br>
For every constant k, there exists a finite sequence of graphs H_1, \ldots, H_{m_k} such that for any graph G<br><br>

G has a vertex cover of size at most k iff no H_i is an (induced) subgraph of G.
<br><br>

This might be surprising since<br><br>

1. the Łoś–Tarski preservation theorem famously fails on finite structures, hence fails on graphs,<br>

2. Lovász's result (and also his proof) is purely combinatorial.
<br><br>
Our key observation is that the above graph-theoretic problem can be easily generalized to infinite graphs. I will explain a few other results we've obtained using such a strategy. Among others, we apply Craig's interpolation theorem to show the collapse of monadic second-order logic to FO on graphs of bounded shrub-depth.
<br><br>
This is joint work with Jörg Flum.
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="hongfei"></a><strong>Title</strong>: Qsimulation: A Tool for Simulating Quantum Computation (Xi Deng)<br>
<strong>Abstract</strong>: We introduce Qsimulation - a tool for simulating quantum computation on classical computers. The tool is composed of four main ingredients: an imperative quantum programming language, an interpreter of the language, a graphic user interface for simulating the execution of quantum programs and error handling module. It is intended to be used by instructors and novices to design and test simple quantum programs and circuits.</p>
<hr>



</body></html>