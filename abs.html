
<!-- saved from url=(0090)https://basics.sjtu.edu.cn/~chen/Events/2017NSFC-JSPS/?from=singlemessage&isappinstalled=0 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>
Abstracts of Talks
</title>
  
  <link type="text/css" href="./The 10th NSFC-JSPS Joint Workshop on Formal Methods_files/hu.css" rel="stylesheet">

<!--<base href="http://basics.sjtu.edu.cn/~chen/.">--><base href=".">

</head><body bgcolor="#F5F5DC" link="#0000F0" vlink="#000090" background="./The 10th NSFC-JSPS Joint Workshop on Formal Methods_files/back.jpg">

<style>
BODY {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}

H1 {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}

P {COLOR: BLACK; FONT-FAMILY: "Georgia", Times, serif}
a {text-decoration:none}
</style>




<h1>Abstracts</h1>

<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="ogawa"></a><strong>Title</strong>: Model checking event clock automata (Mizuhito Ogawa)<br>
<strong>Abstract</strong>: Model checking event clock automata has been an open problem, even for discrete CTL. The difficulty lies the failure of the finite region construction for event clock automata, contrary to what widely believed, We investigate how the well quasi ordering techniques work for the problem. </p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="YuxiFu"></a><strong>Title</strong>: The Quantitative Aspect of Process (Yuxi Fu)<br>
<strong>Abstract</strong>: We take a look at the quantitative aspect of processes by investigating how to count finite nondeterministic computations.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="seki"></a><strong>Title</strong>: Regularity Preservation Property of Register Pushdown Systems (Hiroyuki Seki)<br>
<strong>Abstract</strong>: Pushdown system (PDS) is an infinite-state model for recursive schema and 
PDS preserves regularity, where a transformation T is said to preserve regularity 
if T(L) is always regular for any regular language L. 
Register pushdown system (RPDS) is an extension of PDS by adding the capability 
of manipulating data values in a restricted way.  Murawski et al. showed that 
every RPDS has backward (pre*) regularity preservation property. Note that
we say that a data language L is regular if L is recognized by a register automaton. 
In this talk, we first propose an alternative definition of RPDS by using equivalence 
relation between registers. Then, it is shown that every RPDS has both backward 
and forward (post*) regularity preservation property.  Also, we discuss an application 
of these preservation results to RPDS model checking problems. 
<br>
This is a joint work with Ryoma Senda and Yoshiaki Takata. </p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="terauchi"></a><strong>Title</strong>: A formal analysis of timing channel security via bucketing (Tachio Terauchi)<br>
<strong>Abstract</strong>: Bucketing is a technique proposed to mitigate timing channel attacks by restricting a system's outputs to only occur at designated time intervals. Bucketing has the effect of reducing the possible timing channel observations to a small number of possibilities. In this paper, we present an approach to formally prove the security of systems under the bucketing technique. First, we show that bucketing alone is insufficient to ensure security against adversaries who can make multiple side channel observations. Then, we present a condition sufficient to guarantee a system's security against adaptive side-channel-observing adversaries. Roughly, the condition says that there exists a large enough subset of secrets on which the system's side channel reveals no more information than that revealed by its regular channel and that the regular channel is secure to a certain degree on the subset. We also present a condition which guarantees that the system would satisfy the first condition when bucketing is applied. This second condition says that the system's side-channel outputs are independent of attacker-controlled inputs (but can depend on secrets) and that the regular channel is secure to a certain degree. We show that the two conditions facilitate proving security of systems under adaptive side-channel attacks by separating the concerns of regular-channel security from side-channel information leakage. Further, we show that the bucketing technique can be applied compositionally in conjunction with the constant-time-implementation technique to increase their applicability. While we instantiate our contributions to timing channel and bucketing, many of them are actually quite general and are applicable to any side channels and techniques that reduce the number of possible observations on the channel.
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="nakazawa"></a><strong>Title</strong>: On Cut Elimination in Cyclic Proof Systems for Separation Logic (Koji Nakazawa)<br>
<strong>Abstract</strong>: We prove impossibility of the cut elimination in the cyclic proof
system for the separation logic with general inductive predicates.
We expect that the proof idea can be extended to other cyclic proof
systems for the logic of bunched implication and the first-order logic.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="xinli"></a><strong>Title</strong>:  On relatively-complete tree automata completion and beyond (Xin Li)<br>
<strong>Abstract</strong>: Tree automata completion is a technique for over-approximating the set of terms reachable by rewriting in the term rewriting system for the verification of infinite state systems. In this talk, I will show how to adapt and extend tree automata completion technique to design tree-automata based forward and backward saturation procedures for the safety verification of recursively-typed higher-order recursion scheme, inspired by the connection of intersection types and alternating tree automata shown by Rehof and Urzyczyn in 2011 and type-based saturation algorithm for higher-order model checking. For tree automata completion, soundness of the procedure is well-understood. I will report our preliminary results on how to obtain relatively-complete procedures by fine-tuning the matching and augmenting steps during forward and backward saturation. </p>
<hr>

<p style="width: 800px" align="left"><a name="YuxiFu" id="yuen"></a><strong>Title</strong>: Reversing Parallel Programs with Blocks and Procedures (Shoji Yuen)<br>
<strong>Abstract</strong>: We show how to reverse a while language extended with blocks, local variables, procedures and the
interleaving parallel composition. Annotation is defined along with a set of operational semantics
capable of storing necessary reversal information, and identifiers are introduced to capture the interleaving
order of an execution. Inversion is defined with a set of operational semantics that use
saved information to undo an execution. We prove that annotation does not alter the behaviour of the
original program, and that inversion correctly restores the initial program state.<br>
(Joint work with: James Hoey and Irek Ulidowski)</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="song"></a><strong>Title</strong>: Verifying and Quantifying Side-Channel Resistance of Masked Software Implementations.   (Fu Song) <br>
<strong>Abstract</strong>: Power side-channel attacks, capable of deducing secret data using statistical analysis, have become a serious
threat. Random masking is a widely used countermeasure for removing the statistical dependence between
secret data and side-channel information. Although there are techniques for verifying whether a software
has been perfectly masked, they are limited in accuracy and scalability. To bridge this gap, we propose a
refinement-based method for verifying masking. Our method is more accurate than prior type inference based
approaches and more scalable than prior model-counting based approaches using SAT or SMT solvers. Indeed,
our approach can be viewed as a gradual refinement of a set of type inference rules for reasoning about
distribution types. These rules are kept abstract initially to allow fast deduction, and then made concrete when
the abstract version is not able to resolve the verification problem. We also propose algorithms for quantifying
the amount of information leakage from a software implementation through side channels using the notion of
Quantitative Masking Strength. We have implemented our method in a tool and evaluated it on cryptographic
benchmarks including AES and MAC-Keccak. The experimental results show that our method significantly
outperforms state-of-the-art techniques in terms of both accuracy and scalability.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="deng"></a><strong>Title</strong>: On Divergence-Sensitive Weak Probabilistic Bisimilarity (Kangli He) <br>
<strong>Abstract</strong>: Weak probabilistic bisimilarity is a well-established notion to equate concurrent probabilistic systems that behave observably equivalent, up to the matching of internal computation steps. This notion can be pivotal in the model checking of large probabilistic systems, because the considered model can be replaced by an equivalent, but possibly much smaller one prior to model checking. The conventional work has thus far considered weak probabilistic bisimilarity while ignoring the presence or absence of divergent behavior (interpreted as inﬁnite internal computations). However, we argue that divergence can have a remarkable inﬂuence on the equivalence of two concurrent probabilistic systems. We thus explore divergence-sensitive reﬁnements of weak probabilistic bisimilarity. We work in the setting of probabilistic automata, and study the consistent feasible veriﬁcation method for the notion of divergence-sensitivity that discriminates presence and absence of divergence in otherwise bisimilar states. We furthermore present a novel polynomial-time algorithm to compute divergence-sensitive bisimilarity. It intertwines partition-reﬁnement and inductive veriﬁcation steps in a highly non-trivial manner.</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="gardy"></a><strong>Title</strong>:  Incomplete
information in multi-execution properties for multi-agent systems
 (Patrick Gardy)<br>
<strong>Abstract</strong>:  Imperfect information is a well known and well studied subject of software
verification. In closed systems (systems independent of their environments) there have been many results. When moving to open systems (reacting to their environments), the situation changes
drastically and imperfect information greatly complexify the results. In particular, the model-checking of many models rises in complexity or turn outright undecidable. In this talk we present the different
shapes imperfect information takes in multi-agents systems, some well-known (partial observation of the state space) and some less famous (strategies dependencies during synthesis, delayed use). We
will present recent algorithm developments and new complexity results.
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="chen"></a><strong>Title</strong>: The Complexity of Homomorphism Counts - A Preliminary Report (Yijia Chen)<br>
<strong>Abstract</strong>: In 1967 Lovasz proved that two graphs G and H are isomorphic if and only if
for any (pattern) graph F the number of homomorphisms HOM(F,G) from F to G is
equal to the number of homomorphism HOM(F,H) from F to H. Thus any graph G
can be characterized by the homomorphism vector (HOM(F,G))_F up to
isomorphisms. By restricting pattern graphs F to a given graph class K, e.g.,
trees, planar graphs, bounded-degree graphs, the restricted homomorphism
vector (HOM(F,G))_{F\in K} might offer a meaningful way to measure the
similarly of graphs. For instance, it is shown recently [Dell, Grohe, and
Ratten, 2018] that<br><br>

(*) (HOM(F,G))_{F a tree}= (HOM(F,H))_{F a tree}
<br><br>
if and only if H and G cannot be distinguished by the color-refinement
algorithm, a well-known heuristic for the graph isomorphism problem.<br><br>

Given a class K of graphs, a natural problem is to decide whether (*) holds
for two input graphs G and H. So far this question has not been
systematically investigated.

In this talk I will explain the background of this problem and known results,
and report some of our preliminary findings.
</p>
<hr>
<p style="width: 800px" align="left"><a name="YuxiFu" id="hongfei"></a><strong>Title</strong>: Qsimulation: A Tool for Simulating Quantum Computation (Xi Deng)<br>
<strong>Abstract</strong>: We introduce Qsimulation - a tool for simulating quantum computation on classical computers. The tool is composed of four main ingredients: an imperative quantum programming language, an interpreter of the language, a graphic user interface for simulating the execution of quantum programs and error handling module. It is intended to be used by instructors and novices to design and test simple quantum programs and circuits.</p>
<hr>



</body></html>